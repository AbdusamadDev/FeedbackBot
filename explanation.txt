write code that when FAQ button is clicked in this bot code:




import sqlite3
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.middlewares.logging import LoggingMiddleware
from aiogram.types import (
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    ReplyKeyboardRemove,
)
from aiogram.utils import executor
from aiogram.utils.callback_data import CallbackData
import logging

logging.basicConfig(level=logging.INFO)

API_TOKEN = "6195275934:AAEngBypgfNw3SwcV9uV_jdatZtMvojF9cs"

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)
dp.middleware.setup(LoggingMiddleware())

user_data = {}
region_callback = CallbackData("region", "name")
option_callback = CallbackData("option", "name")
uzbekistan_regions = [
    "Andijan",
    "Bukhara",
    "Fergana",
    "Jizzakh",
    "Khorezm",
    "Namangan",
    "Navoiy",
    "Qashqadaryo",
    "Samarkand",
    "Sirdaryo",
    "Surkhandarya",
    "Tashkent",
    "Tashkent City",
    "Karakalpakstan",
]


def add_user_to_database(user_data):
    """
    Adds a user to the database using the provided user data.
    """
    conn = sqlite3.connect("../db.sqlite3")  # Adjust path if needed
    cursor = conn.cursor()

    # Assuming 'fullname' is a combination of first, middle, and last name
    fullname = f"{user_data['first_name']} {user_data.get('middle_name', '')} {user_data['last_name']}".strip()
    phone_number = user_data['phone_number']
    region = user_data['region']
    telegram_id = user_data['telegram_id']
    telegram_username = user_data.get('telegram_username', '')  # Adjust as necessary

    cursor.execute("""
        INSERT INTO api_user (fullname, phone_number, region, telegram_id, telegram_username) 
        VALUES (?, ?, ?, ?, ?)
    """, (fullname, phone_number, region, telegram_id, telegram_username))

    conn.commit()
    conn.close()


def is_user_in_database(telegram_id):
    conn = sqlite3.connect("../db.sqlite3")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM api_user WHERE telegram_id = ?", (telegram_id,))
    user = cursor.fetchone()
    conn.close()
    return user is not None


@dp.message_handler(commands=["start"])
async def process_start_command(message: types.Message):
    if is_user_in_database(message.from_user.id):
        await present_options(message)
    else:
        user_data[message.from_user.id] = {}
        await message.reply("Hi!\nPlease enter your first name:")


async def present_options(message: types.Message):
    inline_kb = InlineKeyboardMarkup(row_width=3)
    inline_kb.add(
        InlineKeyboardButton("FAQ", callback_data=option_callback.new(name="FAQ"))
    )
    inline_kb.add(
        InlineKeyboardButton(
            "Categories", callback_data=option_callback.new(name="Categories")
        )
    )
    inline_kb.add(
        InlineKeyboardButton("Back", callback_data=option_callback.new(name="Back"))
    )
    await message.reply("Please select an option:", reply_markup=inline_kb)


@dp.message_handler(
    lambda message: "first_name" not in user_data.get(message.from_user.id, {})
)
async def process_first_name(message: types.Message):
    user_data[message.from_user.id] = {"first_name": message.text}
    await message.reply("Please enter your last name:")


@dp.message_handler(
    lambda message: "last_name" not in user_data.get(message.from_user.id, {})
)
async def process_last_name(message: types.Message):
    user_data[message.from_user.id]["last_name"] = message.text
    await message.reply("Please enter your middle name:")


@dp.message_handler(
    lambda message: "middle_name" not in user_data.get(message.from_user.id, {})
)
async def process_middle_name(message: types.Message):
    user_data[message.from_user.id]["middle_name"] = message.text
    await message.reply("Please enter your phone number:")


@dp.message_handler(
    lambda message: "phone_number" not in user_data.get(message.from_user.id, {})
)
async def process_phone_number(message: types.Message):
    user_data[message.from_user.id]["phone_number"] = message.text
    inline_kb = InlineKeyboardMarkup(row_width=2)
    for region in uzbekistan_regions:
        inline_kb.add(
            InlineKeyboardButton(region, callback_data=region_callback.new(name=region))
        )
    await message.reply("Please choose your region:", reply_markup=inline_kb)


@dp.callback_query_handler(region_callback.filter())
async def process_region_selection(query: types.CallbackQuery, callback_data: dict):
    region = callback_data["name"]
    user_data[query.from_user.id]["region"] = region
    user_data[query.from_user.id]["telegram_id"] = query.from_user.id
    user_data[query.from_user.id]["telegram_username"] = query.from_user.username
    add_user_to_database(user_data[query.from_user.id])
    await present_options(query.message)


@dp.callback_query_handler(option_callback.filter())
async def process_option_selection(query: types.CallbackQuery, callback_data: dict):
    option = callback_data["name"]
    await query.message.reply(f"You selected {option}.")
    await query.answer()


@dp.message_handler(lambda message: message.text in ["FAQ", "Categories", "Back"])
async def process_query_options(message: types.Message):
    await message.reply(f"You pressed the {message.text} button.")


@dp.message_handler(
    lambda message: "description" not in user_data.get(message.from_user.id, {})
)
async def process_description(message: types.Message):
    user_data[message.from_user.id]["description"] = message.text
    data = user_data[message.from_user.id]
    response = (
        f"First Name: {data['first_name']}\n"
        f"Last Name: {data['last_name']}\n"
        f"Middle Name: {data['middle_name']}\n"
        f"Phone Number: {data['phone_number']}\n"
        f"Region: {data['region']}\n"
        f"Description: {data.get('description', 'Not provided')}"
    )
    await message.answer(response)


if __name__ == "__main__":
    executor.start_polling(dp)







the faq details from database should be sent one by one. the question should be sent as text and answer of each FAQ question should be binded one button called "see answer" and on see answer button click, the answer binded to that FAQ record should be sent and the models of django follows as:



from django.db import models
from django.contrib.auth.models import User as Admin
from django.core.validators import RegexValidator


class Category(models.Model):
    title = models.CharField(max_length=150)
    admin = models.ForeignKey(to=Admin, on_delete=models.CASCADE)  # Super Admin
    date_created = models.DateTimeField(auto_now_add=True)

    def __str__(self) -> str:
        return self.titlea


class User(models.Model):
    fullname = models.CharField(max_length=100)
    phone_regex = RegexValidator(
        regex=r"^\+\d{8,15}$",
        message="""
            Phone number must be entered in the format: '+9981234567'. 
            Up to 15 digits allowed.
        """,
    )

    phone_number = models.CharField(validators=[phone_regex], max_length=17)
    region = models.CharField(max_length=50)
    telegram_id = models.IntegerField(default=0)
    telegram_username = models.CharField(max_length=60, default="asda")

    def __str__(self) -> str:
        return f"User: {self.fullname} Phone number: {self.phone_number}"


class Question(models.Model):
    CHOICES = ((True, "Yes"), (False, "No"))
    text = models.CharField(max_length=300)
    status = models.BooleanField(choices=CHOICES, default=False)
    category = models.ForeignKey(to=Category, on_delete=models.CASCADE)
    user = models.ForeignKey(to=User, on_delete=models.CASCADE)

    def is_answered(self):
        return self.status == "Yes"

    def __str__(self) -> str:
        return f"{self.text} | Javob berilgan: {self.status}"

    is_answered.boolean = True
    is_answered.short_description = "Answered?"


class FAQ(models.Model):
    question = models.CharField(max_length=200)
    answer = models.TextField(max_length=700)
    admin = models.ForeignKey(to=Admin, on_delete=models.CASCADE)  # Super Admin

    def __str__(self) -> str:
        return f"{self.question}\n\n{self.answer}"


class Answer(models.Model):
    text = models.TextField(max_length=250)
    question = models.ForeignKey(to=Question, on_delete=models.CASCADE)
    admin = models.ForeignKey(to=Admin, on_delete=models.CASCADE)  # Causal Admin

    def __str__(self) -> str:
        return self.text





and the bot source code is located in "/root/bot/main.py"
and the api is located in "/root/manage.py"
the database file is located in "/root/db.sqlite3"